 {
\abnormalparskip{0pt}
\chapter{Implementation}
\label{cha:implementation}
}

This chapter will describe the architecture of the new implementation, i.e.\ how
the new implementation has been structured.

The new implementation has been written in the language Go that is still
relatively new but is considered stable at this point. Quoting the homepage:
``Go is an open source programming language that makes it easy to build simple,
reliable, and efficient software.''~\cite{golanghomepage}. Go is a
general-purpose, strongly typed and garbage-collected language. The syntax bears
resemblance to C\footnote{But with a lot less braces, and no pointer
  arithmetic.}. Furthermore Go has explicit support for concurrent programming.
The language furthermore sports extremely fast compiling of source code and
tries to have performance comparable to C.

The reasoning behind choosing Go for the new implementation were firstly that I
already had experience with the language making it easy to get to work on the
new implementation without also having to learn a new programming language.
Secondly the language has, in my opinion, a very clean syntax which makes it
easily readable for anyone familiar with any C-syntax styled language. Finally
the easy use of concurrency in Go\footnote{Starting a new goroutine, which is
  the languages type of lightweight threads, is as simple as writing:
  \texttt{go~SomeFunction~(args\ldots)}.} made it interesting as continued work
with the new implementation could include a potential and significant speedup by
making the branching of the algorithm concurrent. The same could be be true for
the Gauss elimination\footnote{No concurrency has actually been implemented in
  the new implementation. However the possibilities of this is discussed in
  \cref{sec:concurrency}.}.

In general the implementation tries to follow guidelines given in
\textcite{effectivego}. These are guidelines as to how one codes effective
Go. Here effective means both in terms of speed, memory usage, stability and
readability.

Source code for the new implementation, fixes for the old implementation and
experiments can be found at \url{https://github.com/jsfr/SteinerExact}. The
source code for just the new implementation is also included in
\cref{cha:source-code}.

\section{Overview}
\label{sec:overview-1}

In general the code is structured into a package (or library) called
\texttt{smt} and a main file (which is actually split into a main and
configuration file). This is done to allow for easy reuse of the main amount of
work, as it is a library.

The \texttt{smt} package consists of all the data structures and and their
functions related to calculating \acp{smt}. The main file contains the main
function which initializes a configuration (using the configuration file) and
then starts the main loop of the program with the correct parameters. The main
loop generates topologies, similarly to \citeauthor{smith1992}'s main loop.
Finally the configuration file consists of a data structure and function for
reading the command-line flags.

The possible flags one can pass to the program are:
\begin{itemize}
\item \texttt{-sort} \quad Sorts the terminals before initiating the main loop.
\item \texttt{-1} \quad 1-indexes all printed results on STDOUT. The program is
  0-indexed as this simply makes more sense programming-wise. However one may
  wish a 1-indexed tree when printed for easier comparison with the old
  implementation and the theory.
\item \texttt{-iteration=[method]} \quad Selects the optimization method used.
  \texttt{[method]} can be either \texttt{simple} or \texttt{smith}. The default
  is \texttt{smith}.
\item \texttt{-cpuprofile=[path]} \quad Flag used to initiate a profiling of the
  program. If passed Go's internal profiling is enabled, and the trace is saved
  at \texttt{[path]}. This is only intended for debugging.
\item \texttt{-help,-h} \quad Shows this list of flags. 
\end{itemize}

\section{\acs{smt} Package}
\label{sec:smt-package}

As Go is an imperative language we do not have classes, objects, instances and
so on as in e.g.\ Java. We do however have structs similar to $C$, on which we
can also define functions. Thus the \texttt{smt} package is structured such that
most of the files of it is named similar to the struct and functions on it it
holds. E.g.\ the file \texttt{smt/edge.go} this files contains the struct
defining an edge, and the methods on this, such as calculating the length of the
edge.

\subsection{Structs}
\label{sec:structs}

The most important structs for the new implementation are:
%
\begin{itemize}
\item \textbf{Point} \quad Represents a $d$ dimensional
  point. Implemented as a simple array of floats. For convenience points has a
  number of functions for subtracting points, calculating dot products, and
  finally the function for sorting terminals, which is simply implemented as a
  function that takes a list of points and sorts them as described in \cref{sec:sorting-terminals}.
\item \textbf{Edge} \quad Represents an edge of a tree. The edge
  consists of a pointer to the tree and two integers which are the indicies of
  the end points of the edge in the point-array of the tree. The pointer is
  needed of for the indicies to make sense, and to easily calculate the length
  of the edge.
\item \textbf{Tree} \quad Represents a complete tree. The struct
  contains a list of all edges, a list of points, the dimension of the the
  points and the number of points which are terminals. Finally the struct also
  contains a list of adjacencies to the Steiner points, as this was considered
  the easiest way to hold these, instead of having to find them every time they
  are needed in the edges. The most important functions (besides the iterations)
  on a tree are those for splitting and restoring an edge, and the function for
  calculating the error of the tree.
\item \textbf{Stack} \quad The implementation of \citeauthor{smith1992}'s
  iteration utilizes quite a few stacks. These were in the original
  implementation just arrays on which \citeauthor{smith1992} made sure to always
  index as if it was a stack. To ensure that the stacks are always used
  correctly, the new implementation instead implements a simple stack struct,
  which just consists of an array as the underlying structure, and then
  functions for pushing and popping elements of the stack.
\end{itemize}

\subsection{Helpers}
\label{sec:helpers}

The \texttt{smt} package also contains a number of helpers. These are function
for calculating the pertubed centroid of three points, calculating the
Fermat-Torricelli point of three points, printing a trees representation to the
console. Only the function for printing a tree to console can be accessed
outside the package. The others are for internal use only.

\subsection{Iterations}
\label{sec:iterations-1}

The package also contains a file, named \texttt{optimize.go} with an
implementation of the two different iterations. The first one is the iteration
described by \textcite{smith1992} (named \texttt{SmithsIteration}) and the
second is the iteration based on the simple iteration described in
\cref{sec:simple-iteration} using the analytical solution for the
Fermat-Torricelli problem presented by \textcite{uteshev2014} to place the
Steiner points (named \texttt{SimpleIteration}).

The second iteration is relatively simple in its iteration. It iterates
through all Steiner points, calculating their placement with regard to the
other points' current placement.

The first iteration in general follows the same outline as done in the original
implementation. In the same way it also utilizes a number of arrays and stacks
which are global to the package (but inaccessible from the outside to avoid
someone using the library from tampering with the data mid-iteration
unintentionally). In general these global arrays is unwanted as it clutters the
space of the other functions in the package. However initial runs of the
iteration showed that the new implementation used a significant amount of time
in the iteration on creating new local arrays every time it was being run. This
was of course undesirable, as it both wasted time, and made comparison to the
original code harder. Thus after some consideration, and for lack of a better
solution, I decided to continue using global variables for the arrays and stacks
of \texttt{SmithsIteration}.

\section{Main and Configuration File}
\label{sec:main-file}

The new implementation contains a main file, and a configuration file.

The main file contains the main function being run when the program is executed
on the command-line, and the main loop for enumerating and optimizing
topologies. This is done using the structs and functions of the \texttt{smt}
package, i.e.\ its public API. The main loop in general follow the same outline
as the main loop of \citeauthor{smith1992}'s original implementation.

The main file furthermore uses the functions and structs of the configuration
file for reading and handling the arguments given on the command-line. The
implementation unlike \citeauthor{smith1992}'s implementation does not read a
list of terminals on STDIN, but instead takes as argument a file-path to what it
expects to be a JSON file containing a list, named \textit{``points''},
consisting of equal length lists, corresponding to the terminals. The file uses
standard JSON syntax~\cite{ecma404}.

\section{Other Source Code and Files}
\label{sec:other-source-code}

Finally, at the repository for the implementation,
\url{https://github.com/jsfr/SteinerExact}, one can also find code not directly
related to the implementation, but instead related to the thesis as a
whole. Apart from the implementation, the repository also contains all tree
instances that has been used during the experiments, and all scripts for running
and aggregating the experimental data. It also contains the runs on which
\cref{cha:experiments} is based.

Furthermore the repository also contains version 3.1 of the GeoSteiner package,
which can also be found at \url{http://www.geosteiner.com}, also used by the
experiments and the implementation by \textcite{smith1992} with the bugfix for
the if-condition described in \cref{sec:if-clause-when} and added counting of
trees and iterations.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
